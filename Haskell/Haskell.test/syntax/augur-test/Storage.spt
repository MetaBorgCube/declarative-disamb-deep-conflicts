module Storage

 language Haskell start symbol Module

 test Storage [[module Storage
    ( addSerie
    , removeSerie
    , getTitles
    , lookupSerieName
    , listAllSeries
    ) where

import System.Directory
import System.FilePath
import Control.Monad
import System.Exit
import System.Directory
import System.IO
import System.IO.Unsafe
import Data.List

import Utils
import Types
import Epguide
import Config

{-

$DATA/.augur/serie.titles

-}

addSerie :: SerieName -> IO ()
addSerie name
    = do file <- getTitlesFile name
         mbSerie <- lookupSerieName name
         case mbSerie of
           Nothing    -> writeFile file "[]"
           Just serie -> do hPutStrLn stderr $ "Serie already exist: " ++ serie
                            exitWith $ ExitFailure 1

removeSerie :: SerieName -> IO ()
removeSerie name
    = do mbSerie <- lookupSerieName name
         case mbSerie of
           Nothing    -> do hPutStrLn stderr $ "Unknown serie: " ++ name
           Just serie -> do file <- getTitlesFile serie
                            removeFile file


getTitles :: Config -> SerieName -> IO [(LocalEpisodeIndex, String)]
getTitles cfg name
    = do mbSerie <- lookupSerieName name
         case mbSerie of
           Nothing    -> return []
           Just serie -> do lst <- fmap read . readFile =<< getTitlesFile serie
                            let lazyFetch = unsafePerformIO $
                                            do extra <- fetchTitles cfg serie
                                               let newElts = extra \\ lst
                                               unless (confDryRun cfg) $ setTitles serie extra
                                               return newElts
                            return $ lst ++ lazyFetch

setTitles :: SerieName -> [(LocalEpisodeIndex, String)] -> IO ()
setTitles serie lst
    = do tmp <- getTemporaryDirectory
         (path, handle) <- openTempFile tmp "titles.txt"
         hPrint handle lst
         hClose handle
         destPath <- getTitlesFile serie
         renameFile path destPath

-- trunc name -> name
lookupSerieName :: SerieName -> IO (Maybe SerieName)
lookupSerieName name
    = do series <- listAllSeries
         return $ lookup (trunc name) [ (trunc s, s) | s <- series ]

listAllSeries :: IO [SerieName]
listAllSeries =
    do dir <- getAppUserDataDirectory "augur"
       contents <- getDirectoryContents dir
       return $ nub $ map takeBaseName $ filter (`notElem` [".",".."]) contents

getTitlesFile :: SerieName -> IO FilePath
getTitlesFile name
    = do dir <- getAppUserDataDirectory "augur"
         createDirectoryIfMissing True dir
         return $ dir </> name <.> "titles"]] parse succeeds
